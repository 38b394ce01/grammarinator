# Generated by Grammarinator 19.3+48.g5578729

from itertools import chain
from math import inf
from grammarinator.runtime import *

charset_0 = list(chain(*multirange_diff(printable_unicode_ranges, [(60, 61)])))
charset_1 = list(chain(range(9, 10), range(10, 11), range(13, 14), range(32, 33)))
charset_2 = list(chain(range(48, 58), range(65, 71), range(97, 103)))
charset_3 = list(chain(range(48, 58)))
charset_4 = list(chain(range(58, 59), range(65, 91), range(97, 123)))
charset_5 = list(chain(range(32, 33)))
charset_6 = list(chain(range(48, 58), range(65, 91), range(97, 123)))
charset_7 = list(chain(range(48, 58), range(65, 71), range(97, 103)))
charset_8 = list(chain(range(48, 58)))
charset_9 = list(chain(*multirange_diff(printable_unicode_ranges, [(34, 35), (60, 61)])))
charset_10 = list(chain(*multirange_diff(printable_unicode_ranges, [(39, 40), (60, 61)])))


def html_space_serializer(root):

    def _walk(node):
        nonlocal src
        for child in node.children:
            _walk(child)

        if isinstance(node, UnlexerRule) and node.src:
            src += node.src

        if (isinstance(node, UnparserRule) and
            node.name == 'htmlTagName' and node.right_sibling and node.right_sibling.name == 'htmlAttribute' or node.name == 'htmlAttribute') \
                or isinstance(node, UnlexerRule) and node.src and node.src.endswith(('<script', '<style', '<?xml')):
            src += ' '

    src = ''
    _walk(root)
    return src


class HTMLGenerator(Generator):

    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        self.any_char = self.any_unicode_char

    def style_sheet(self, parent=None):
        return UnlexerRule(src='', parent=parent)


    def endOfHtmlElement(self):
        pass

    @depthcontrol
    def EOF(self, parent=None):
        pass
    EOF.min_depth = 0

    @depthcontrol
    def HTML_COMMENT(self, parent=None):
        current = UnlexerRule(name='HTML_COMMENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<!--', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src='-->', parent=current)
        self.exit_rule(current)
        return current
    HTML_COMMENT.min_depth = 0

    @depthcontrol
    def HTML_CONDITIONAL_COMMENT(self, parent=None):
        current = UnlexerRule(name='HTML_CONDITIONAL_COMMENT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<![', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src=']>', parent=current)
        self.exit_rule(current)
        return current
    HTML_CONDITIONAL_COMMENT.min_depth = 0

    @depthcontrol
    def XML_DECLARATION(self, parent=None):
        current = UnlexerRule(name='XML_DECLARATION', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<?xml', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    XML_DECLARATION.min_depth = 0

    @depthcontrol
    def CDATA(self, parent=None):
        current = UnlexerRule(name='CDATA', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<![CDATA[', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src=']]>', parent=current)
        self.exit_rule(current)
        return current
    CDATA.min_depth = 0

    @depthcontrol
    def DTD(self, parent=None):
        current = UnlexerRule(name='DTD', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<!', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    DTD.min_depth = 0

    @depthcontrol
    def SCRIPTLET(self, parent=None):
        current = UnlexerRule(name='SCRIPTLET', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            UnlexerRule(src='<?', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    UnlexerRule(src=self.any_char(), parent=current)
            UnlexerRule(src='?>', parent=current)
        elif choice == 1:
            UnlexerRule(src='<%', parent=current)
            if self.max_depth >= 0:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    UnlexerRule(src=self.any_char(), parent=current)
            UnlexerRule(src='%>', parent=current)
        self.exit_rule(current)
        return current
    SCRIPTLET.min_depth = 0

    @depthcontrol
    def SEA_WS(self, parent=None):
        current = UnlexerRule(name='SEA_WS', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                choice = self.model.choice(current, 0, [0 if [0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    UnlexerRule(src=' ', parent=current)
                elif choice == 1:
                    UnlexerRule(src='\t', parent=current)
                elif choice == 2:
                    if self.max_depth >= 0:
                        for _ in self.model.quantify(current, 1, min=0, max=1):
                            UnlexerRule(src='\r', parent=current)
                    UnlexerRule(src='\n', parent=current)
        self.exit_rule(current)
        return current
    SEA_WS.min_depth = 0

    @depthcontrol
    def SCRIPT_OPEN(self, parent=None):
        current = UnlexerRule(name='SCRIPT_OPEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<script', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    SCRIPT_OPEN.min_depth = 0

    @depthcontrol
    def STYLE_OPEN(self, parent=None):
        current = UnlexerRule(name='STYLE_OPEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<style', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    STYLE_OPEN.min_depth = 0

    @depthcontrol
    def TAG_OPEN(self, parent=None):
        current = UnlexerRule(name='TAG_OPEN', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='<', parent=current)
        self.exit_rule(current)
        return current
    TAG_OPEN.min_depth = 0

    @depthcontrol
    def HTML_TEXT(self, parent=None):
        current = UnlexerRule(name='HTML_TEXT', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.char_from_list(charset_0), parent=current)
        self.exit_rule(current)
        return current
    HTML_TEXT.min_depth = 0

    @depthcontrol
    def TAG_CLOSE(self, parent=None):
        current = UnlexerRule(name='TAG_CLOSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='>', parent=current)
        self.exit_rule(current)
        return current
    TAG_CLOSE.min_depth = 0

    @depthcontrol
    def TAG_SLASH_CLOSE(self, parent=None):
        current = UnlexerRule(name='TAG_SLASH_CLOSE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/>', parent=current)
        self.exit_rule(current)
        return current
    TAG_SLASH_CLOSE.min_depth = 0

    @depthcontrol
    def TAG_SLASH(self, parent=None):
        current = UnlexerRule(name='TAG_SLASH', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='/', parent=current)
        self.exit_rule(current)
        return current
    TAG_SLASH.min_depth = 0

    @depthcontrol
    def TAG_EQUALS(self, parent=None):
        current = UnlexerRule(name='TAG_EQUALS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='=', parent=current)
        self.exit_rule(current)
        return current
    TAG_EQUALS.min_depth = 0

    @depthcontrol
    def TAG_NAME(self, parent=None):
        current = UnlexerRule(name='TAG_NAME', parent=parent)
        self.enter_rule(current)
        self.TAG_NameStartChar(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.TAG_NameChar(parent=current)
        self.exit_rule(current)
        return current
    TAG_NAME.min_depth = 1

    @depthcontrol
    def TAG_WHITESPACE(self, parent=None):
        current = UnlexerRule(name='TAG_WHITESPACE', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.char_from_list(charset_1), parent=current)
        self.exit_rule(current)
        return current
    TAG_WHITESPACE.min_depth = 0

    @depthcontrol
    def HEXDIGIT(self, parent=None):
        current = UnlexerRule(name='HEXDIGIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.char_from_list(charset_2), parent=current)
        self.exit_rule(current)
        return current
    HEXDIGIT.min_depth = 0

    @depthcontrol
    def DIGIT(self, parent=None):
        current = UnlexerRule(name='DIGIT', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src=self.char_from_list(charset_3), parent=current)
        self.exit_rule(current)
        return current
    DIGIT.min_depth = 0

    @depthcontrol
    def TAG_NameChar(self, parent=None):
        current = UnlexerRule(name='TAG_NameChar', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 0, 0, 0, 1, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.TAG_NameStartChar(parent=current)
        elif choice == 1:
            UnlexerRule(src='-', parent=current)
        elif choice == 2:
            UnlexerRule(src='_', parent=current)
        elif choice == 3:
            UnlexerRule(src='.', parent=current)
        elif choice == 4:
            self.DIGIT(parent=current)
        elif choice == 5:
            UnlexerRule(src='\u00B7', parent=current)
        elif choice == 6:
            UnlexerRule(src=self.char_from_list(range(768, 879)), parent=current)
        elif choice == 7:
            UnlexerRule(src=self.char_from_list(range(8255, 8256)), parent=current)
        self.exit_rule(current)
        return current
    TAG_NameChar.min_depth = 0

    @depthcontrol
    def TAG_NameStartChar(self, parent=None):
        current = UnlexerRule(name='TAG_NameStartChar', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src=self.char_from_list(charset_4), parent=current)
        elif choice == 1:
            UnlexerRule(src=self.char_from_list(range(8304, 8591)), parent=current)
        elif choice == 2:
            UnlexerRule(src=self.char_from_list(range(11264, 12271)), parent=current)
        elif choice == 3:
            UnlexerRule(src=self.char_from_list(range(12289, 55295)), parent=current)
        elif choice == 4:
            UnlexerRule(src=self.char_from_list(range(63744, 64975)), parent=current)
        elif choice == 5:
            UnlexerRule(src=self.char_from_list(range(65008, 65533)), parent=current)
        self.exit_rule(current)
        return current
    TAG_NameStartChar.min_depth = 0

    @depthcontrol
    def SCRIPT_BODY(self, parent=None):
        current = UnlexerRule(name='SCRIPT_BODY', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src='</script>', parent=current)
        self.exit_rule(current)
        return current
    SCRIPT_BODY.min_depth = 0

    @depthcontrol
    def SCRIPT_SHORT_BODY(self, parent=None):
        current = UnlexerRule(name='SCRIPT_SHORT_BODY', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.any_char(), parent=current)
        UnlexerRule(src='</>', parent=current)
        self.exit_rule(current)
        return current
    SCRIPT_SHORT_BODY.min_depth = 0

    @depthcontrol
    def STYLE_BODY(self, parent=None):
        current = UnlexerRule(name='STYLE_BODY', parent=parent)
        self.enter_rule(current)
        current += self.style_sheet()
        UnlexerRule(src='</style>', parent=current)
        self.exit_rule(current)
        return current
    STYLE_BODY.min_depth = 0

    @depthcontrol
    def STYLE_SHORT_BODY(self, parent=None):
        current = UnlexerRule(name='STYLE_SHORT_BODY', parent=parent)
        self.enter_rule(current)
        current += self.style_sheet()
        UnlexerRule(src='</>', parent=current)
        self.exit_rule(current)
        return current
    STYLE_SHORT_BODY.min_depth = 0

    @depthcontrol
    def ATTVALUE_VALUE(self, parent=None):
        current = UnlexerRule(name='ATTVALUE_VALUE', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.char_from_list(charset_5), parent=current)
        self.ATTRIBUTE(parent=current)
        self.exit_rule(current)
        return current
    ATTVALUE_VALUE.min_depth = 2

    @depthcontrol
    def ATTRIBUTE(self, parent=None):
        current = UnlexerRule(name='ATTRIBUTE', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1, 2, 1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1])])
        if choice == 0:
            self.DOUBLE_QUOTE_STRING(parent=current)
        elif choice == 1:
            self.SINGLE_QUOTE_STRING(parent=current)
        elif choice == 2:
            self.ATTCHARS(parent=current)
        elif choice == 3:
            self.HEXCHARS(parent=current)
        elif choice == 4:
            self.DECCHARS(parent=current)
        self.exit_rule(current)
        return current
    ATTRIBUTE.min_depth = 1

    @depthcontrol
    def ATTCHAR(self, parent=None):
        current = UnlexerRule(name='ATTCHAR', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1])])
        if choice == 0:
            UnlexerRule(src='-', parent=current)
        elif choice == 1:
            UnlexerRule(src='_', parent=current)
        elif choice == 2:
            UnlexerRule(src='.', parent=current)
        elif choice == 3:
            UnlexerRule(src='/', parent=current)
        elif choice == 4:
            UnlexerRule(src='+', parent=current)
        elif choice == 5:
            UnlexerRule(src=',', parent=current)
        elif choice == 6:
            UnlexerRule(src='?', parent=current)
        elif choice == 7:
            UnlexerRule(src='=', parent=current)
        elif choice == 8:
            UnlexerRule(src=':', parent=current)
        elif choice == 9:
            UnlexerRule(src=';', parent=current)
        elif choice == 10:
            UnlexerRule(src='#', parent=current)
        elif choice == 11:
            UnlexerRule(src=self.char_from_list(charset_6), parent=current)
        self.exit_rule(current)
        return current
    ATTCHAR.min_depth = 0

    @depthcontrol
    def ATTCHARS(self, parent=None):
        current = UnlexerRule(name='ATTCHARS', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                self.ATTCHAR(parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src=' ', parent=current)
        self.exit_rule(current)
        return current
    ATTCHARS.min_depth = 1

    @depthcontrol
    def HEXCHARS(self, parent=None):
        current = UnlexerRule(name='HEXCHARS', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='#', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.char_from_list(charset_7), parent=current)
        self.exit_rule(current)
        return current
    HEXCHARS.min_depth = 0

    @depthcontrol
    def DECCHARS(self, parent=None):
        current = UnlexerRule(name='DECCHARS', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=1, max=inf):
                UnlexerRule(src=self.char_from_list(charset_8), parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                UnlexerRule(src='%', parent=current)
        self.exit_rule(current)
        return current
    DECCHARS.min_depth = 0

    @depthcontrol
    def DOUBLE_QUOTE_STRING(self, parent=None):
        current = UnlexerRule(name='DOUBLE_QUOTE_STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='"', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.char_from_list(charset_9), parent=current)
        UnlexerRule(src='"', parent=current)
        self.exit_rule(current)
        return current
    DOUBLE_QUOTE_STRING.min_depth = 0

    @depthcontrol
    def SINGLE_QUOTE_STRING(self, parent=None):
        current = UnlexerRule(name='SINGLE_QUOTE_STRING', parent=parent)
        self.enter_rule(current)
        UnlexerRule(src='\'', parent=current)
        if self.max_depth >= 0:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                UnlexerRule(src=self.char_from_list(charset_10), parent=current)
        UnlexerRule(src='\'', parent=current)
        self.exit_rule(current)
        return current
    SINGLE_QUOTE_STRING.min_depth = 0

    @depthcontrol
    def htmlDocument(self, parent=None):
        current = UnparserRule(name='htmlDocument', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.scriptlet(parent=current)
                elif choice == 1:
                    self.SEA_WS(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=1):
                self.xml(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 2, min=0, max=inf):
                choice = self.model.choice(current, 1, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.scriptlet(parent=current)
                elif choice == 1:
                    self.SEA_WS(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 3, min=0, max=1):
                self.dtd(parent=current)
        if self.max_depth >= 1:
            for _ in self.model.quantify(current, 4, min=0, max=inf):
                choice = self.model.choice(current, 2, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
                if choice == 0:
                    self.scriptlet(parent=current)
                elif choice == 1:
                    self.SEA_WS(parent=current)
        if self.max_depth >= 4:
            for _ in self.model.quantify(current, 5, min=0, max=inf):
                self.htmlElements(parent=current)
        self.exit_rule(current)
        return current
    htmlDocument.min_depth = 0

    @depthcontrol
    def htmlElements(self, parent=None):
        current = UnparserRule(name='htmlElements', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=inf):
                self.htmlMisc(parent=current)
        self.htmlElement(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                self.htmlMisc(parent=current)
        self.exit_rule(current)
        return current
    htmlElements.min_depth = 3

    @depthcontrol
    def htmlElement(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='htmlElement', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [3, 3, 3, 2, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1, 1, 1, 1])])
        if choice == 0:
            self.TAG_OPEN(parent=current)
            self.htmlTagName(parent=current)
            local_ctx['open_tag'] = current.last_child
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 0, min=0, max=inf):
                    self.htmlAttribute(parent=current)
            self.TAG_CLOSE(parent=current)
            self.htmlContent(parent=current)
            self.TAG_OPEN(parent=current)
            self.TAG_SLASH(parent=current)
            self.htmlTagName(parent=current)
            current.last_child = local_ctx['open_tag'].deepcopy()
            self.TAG_CLOSE(parent=current)
            self.endOfHtmlElement()
        elif choice == 1:
            self.TAG_OPEN(parent=current)
            self.htmlTagName(parent=current)
            local_ctx['open_tag'] = current.last_child
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 1, min=0, max=inf):
                    self.htmlAttribute(parent=current)
            self.TAG_SLASH_CLOSE(parent=current)
            self.endOfHtmlElement()
        elif choice == 2:
            self.TAG_OPEN(parent=current)
            self.htmlTagName(parent=current)
            local_ctx['open_tag'] = current.last_child
            if self.max_depth >= 4:
                for _ in self.model.quantify(current, 2, min=0, max=inf):
                    self.htmlAttribute(parent=current)
            self.TAG_CLOSE(parent=current)
            self.endOfHtmlElement()
        elif choice == 3:
            self.scriptlet(parent=current)
        elif choice == 4:
            self.script(parent=current)
        elif choice == 5:
            self.style(parent=current)
        self.exit_rule(current)
        return current
    htmlElement.min_depth = 2

    @depthcontrol
    def htmlContent(self, parent=None):
        current = UnparserRule(name='htmlContent', parent=parent)
        self.enter_rule(current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 0, min=0, max=1):
                self.htmlChardata(parent=current)
        if self.max_depth >= 2:
            for _ in self.model.quantify(current, 1, min=0, max=inf):
                choice = self.model.choice(current, 0, [0 if [3, 2, 2][i] > self.max_depth else w for i, w in enumerate([1, 1, 1])])
                if choice == 0:
                    self.htmlElement(parent=current)
                elif choice == 1:
                    self.xhtmlCDATA(parent=current)
                elif choice == 2:
                    self.htmlComment(parent=current)
                if self.max_depth >= 2:
                    for _ in self.model.quantify(current, 2, min=0, max=1):
                        self.htmlChardata(parent=current)
        self.exit_rule(current)
        return current
    htmlContent.min_depth = 0

    @depthcontrol
    def htmlAttribute(self, parent=None):
        local_ctx = dict()
        current = UnparserRule(name='htmlAttribute', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [4, 3][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.htmlAttributeName(parent=current)
            local_ctx['attr_name'] = current.last_child
            self.TAG_EQUALS(parent=current)
            self.htmlAttributeValue(parent=current)
        elif choice == 1:
            self.htmlAttributeName(parent=current)
            local_ctx['attr_name'] = current.last_child
        self.exit_rule(current)
        return current
    htmlAttribute.min_depth = 3

    @depthcontrol
    def htmlAttributeName(self, parent=None):
        current = UnparserRule(name='htmlAttributeName', parent=parent)
        self.enter_rule(current)
        self.TAG_NAME(parent=current)
        self.exit_rule(current)
        return current
    htmlAttributeName.min_depth = 2

    @depthcontrol
    def htmlAttributeValue(self, parent=None):
        current = UnparserRule(name='htmlAttributeValue', parent=parent)
        self.enter_rule(current)
        self.ATTVALUE_VALUE(parent=current)
        self.exit_rule(current)
        return current
    htmlAttributeValue.min_depth = 3

    @depthcontrol
    def htmlTagName(self, parent=None):
        current = UnparserRule(name='htmlTagName', parent=parent)
        self.enter_rule(current)
        self.TAG_NAME(parent=current)
        self.exit_rule(current)
        return current
    htmlTagName.min_depth = 2

    @depthcontrol
    def htmlChardata(self, parent=None):
        current = UnparserRule(name='htmlChardata', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.HTML_TEXT(parent=current)
        elif choice == 1:
            self.SEA_WS(parent=current)
        self.exit_rule(current)
        return current
    htmlChardata.min_depth = 1

    @depthcontrol
    def htmlMisc(self, parent=None):
        current = UnparserRule(name='htmlMisc', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [2, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.htmlComment(parent=current)
        elif choice == 1:
            self.SEA_WS(parent=current)
        self.exit_rule(current)
        return current
    htmlMisc.min_depth = 1

    @depthcontrol
    def htmlComment(self, parent=None):
        current = UnparserRule(name='htmlComment', parent=parent)
        self.enter_rule(current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.HTML_COMMENT(parent=current)
        elif choice == 1:
            self.HTML_CONDITIONAL_COMMENT(parent=current)
        self.exit_rule(current)
        return current
    htmlComment.min_depth = 1

    @depthcontrol
    def xhtmlCDATA(self, parent=None):
        current = UnparserRule(name='xhtmlCDATA', parent=parent)
        self.enter_rule(current)
        self.CDATA(parent=current)
        self.exit_rule(current)
        return current
    xhtmlCDATA.min_depth = 1

    @depthcontrol
    def dtd(self, parent=None):
        current = UnparserRule(name='dtd', parent=parent)
        self.enter_rule(current)
        self.DTD(parent=current)
        self.exit_rule(current)
        return current
    dtd.min_depth = 1

    @depthcontrol
    def xml(self, parent=None):
        current = UnparserRule(name='xml', parent=parent)
        self.enter_rule(current)
        self.XML_DECLARATION(parent=current)
        self.exit_rule(current)
        return current
    xml.min_depth = 1

    @depthcontrol
    def scriptlet(self, parent=None):
        current = UnparserRule(name='scriptlet', parent=parent)
        self.enter_rule(current)
        self.SCRIPTLET(parent=current)
        self.exit_rule(current)
        return current
    scriptlet.min_depth = 1

    @depthcontrol
    def script(self, parent=None):
        current = UnparserRule(name='script', parent=parent)
        self.enter_rule(current)
        self.SCRIPT_OPEN(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.SCRIPT_BODY(parent=current)
        elif choice == 1:
            self.SCRIPT_SHORT_BODY(parent=current)
        self.exit_rule(current)
        return current
    script.min_depth = 1

    @depthcontrol
    def style(self, parent=None):
        current = UnparserRule(name='style', parent=parent)
        self.enter_rule(current)
        self.STYLE_OPEN(parent=current)
        choice = self.model.choice(current, 0, [0 if [1, 1][i] > self.max_depth else w for i, w in enumerate([1, 1])])
        if choice == 0:
            self.STYLE_BODY(parent=current)
        elif choice == 1:
            self.STYLE_SHORT_BODY(parent=current)
        self.exit_rule(current)
        return current
    style.min_depth = 1

    default_rule = htmlDocument
